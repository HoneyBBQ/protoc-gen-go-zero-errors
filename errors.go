package main

import (
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"

	errorspb "github.com/honeybbq/go-zero-errors-proto/errors"
)

// generateFile generates the errors code for a single proto file
func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Enums) == 0 {
		return
	}

	filename := file.GeneratedFilenamePrefix + "_errors.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	// Generate file header
	generateHeader(g, file)

	// Generate errors for each enum
	for _, enum := range file.Enums {
		generateEnum(g, enum)
	}
}

// getGoPackageName extracts the correct package name from go_package option
func getGoPackageName(file *protogen.File) string {
	// 检查是否有显式指定的包名（格式：path;package）
	goPackageOption := file.Proto.GetOptions().GetGoPackage()

	if goPackageOption != "" {
		// 如果包含分号，分号后面是包名
		if parts := strings.Split(goPackageOption, ";"); len(parts) == 2 {
			return strings.TrimSpace(parts[1])
		}
		// 否则使用路径的最后一部分
		if parts := strings.Split(goPackageOption, "/"); len(parts) > 0 {
			return strings.TrimSpace(parts[len(parts)-1])
		}
	}

	// 如果没有go_package选项，使用protogen提供的包名
	return string(file.GoPackageName)
}

// generateHeader generates the file header with package and imports
func generateHeader(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by protoc-gen-go-zero-errors. DO NOT EDIT.")
	g.P()
	g.P("package ", getGoPackageName(file))
	g.P()
	g.P("import (")
	g.P(`	"fmt"`)
	g.P()
	g.P(`	errors "`, errorsPkgPath, `"`)
	g.P(")")
	g.P()
}

// generateEnum generates error functions for an enum
func generateEnum(g *protogen.GeneratedFile, enum *protogen.Enum) {
	// Get default code from enum options
	defaultCode := getDefaultCode(enum.Desc.Options())

	// Generate error functions for each enum value
	for _, value := range enum.Values {
		generateErrorFunc(g, enum, value, defaultCode)
		generateIsFunc(g, enum, value)
	}
}

// generateErrorFunc generates xx function
func generateErrorFunc(g *protogen.GeneratedFile, enum *protogen.Enum, value *protogen.EnumValue, defaultCode int32) {
	// Get custom code or use default
	code := getValueCode(value.Desc.Options(), defaultCode)

	// Get comment from proto
	comment := getValueComment(value)

	// Generate function name
	funcName := "Error" + camelCase(string(value.Desc.Name()))

	// Generate function
	if comment != "" {
		g.P("// ", funcName, " ", comment)
	}
	g.P("func ", funcName, "(format string, args ...interface{}) *errors.Error {")
	g.P(`	return errors.New(`, code, `, "`, value.Desc.Name(), `", fmt.Sprintf(format, args...))`)
	g.P("}")
	g.P()
}

// generateIsFunc generates IsXxx function
func generateIsFunc(g *protogen.GeneratedFile, enum *protogen.Enum, value *protogen.EnumValue) {
	// Generate function name
	funcName := "Is" + camelCase(string(value.Desc.Name()))

	// Generate function
	g.P("// ", funcName, " determines if err is an error which indicates a ", value.Desc.Name(), " error.")
	g.P("// It supports wrapped errors.")
	g.P("func ", funcName, "(err error) bool {")
	g.P(`	return errors.Reason(err) == "`, value.Desc.Name(), `"`)
	g.P("}")
	g.P()
}

// getDefaultCode extracts default_code from enum options
func getDefaultCode(opts proto.Message) int32 {
	if opts == nil {
		return 500 // default to 500
	}

	if enumOpts, ok := opts.(*descriptorpb.EnumOptions); ok {
		if proto.HasExtension(enumOpts, errorspb.E_DefaultCode) {
			if code := proto.GetExtension(enumOpts, errorspb.E_DefaultCode); code != nil {
				if c, ok := code.(int32); ok {
					return c
				}
			}
		}
	}
	return 500
}

// getValueCode extracts code from enum value options
func getValueCode(opts proto.Message, defaultCode int32) int32 {
	if opts == nil {
		return defaultCode
	}

	if valueOpts, ok := opts.(*descriptorpb.EnumValueOptions); ok {
		if proto.HasExtension(valueOpts, errorspb.E_Code) {
			if code := proto.GetExtension(valueOpts, errorspb.E_Code); code != nil {
				if c, ok := code.(int32); ok {
					return c
				}
			}
		}
	}
	return defaultCode
}

// getValueComment extracts comment from enum value
func getValueComment(value *protogen.EnumValue) string {
	if value.Comments.Leading != "" {
		return strings.TrimSpace(string(value.Comments.Leading))
	}
	if value.Comments.Trailing != "" {
		return strings.TrimSpace(string(value.Comments.Trailing))
	}
	return ""
}

// camelCase converts snake_case to CamelCase
func camelCase(s string) string {
	if s == "" {
		return ""
	}

	parts := strings.Split(strings.ToLower(s), "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

const errorsPkgPath = "github.com/honeybbq/protoc-gen-go-zero-errors/errors"
